var n=63710088e-1,f={centimeters:n*100,centimetres:n*100,degrees:360/(2*Math.PI),feet:n*3.28084,inches:n*39.37,kilometers:n/1e3,kilometres:n/1e3,meters:n,metres:n,miles:n/1609.344,millimeters:n*1e3,millimetres:n*1e3,nauticalmiles:n/1852,radians:1,yards:n*1.0936};function s(e,t,r={}){const i={type:"Feature"};return(r.id===0||r.id)&&(i.id=r.id),r.bbox&&(i.bbox=r.bbox),i.properties=t||{},i.geometry=e,i}function u(e,t,r={}){if(!e)throw new Error("coordinates is required");if(!Array.isArray(e))throw new Error("coordinates must be an Array");if(e.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!l(e[0])||!l(e[1]))throw new Error("coordinates must contain numbers");return s({type:"Point",coordinates:e},t,r)}function c(e,t,r={}){for(const o of e){if(o.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(o[o.length-1].length!==o[0].length)throw new Error("First and last Position are not equivalent.");for(let a=0;a<o[o.length-1].length;a++)if(o[o.length-1][a]!==o[0][a])throw new Error("First and last Position are not equivalent.")}return s({type:"Polygon",coordinates:e},t,r)}function g(e,t,r={}){if(e.length<2)throw new Error("coordinates must be an array of two or more positions");return s({type:"LineString",coordinates:e},t,r)}function h(e,t={}){const r={type:"FeatureCollection"};return t.id&&(r.id=t.id),t.bbox&&(r.bbox=t.bbox),r.features=e,r}function m(e,t="kilometers"){const r=f[t];if(!r)throw new Error(t+" units is invalid");return e*r}function d(e,t="kilometers"){const r=f[t];if(!r)throw new Error(t+" units is invalid");return e/r}function w(e){return e%(2*Math.PI)*180/Math.PI}function b(e){return e%360*Math.PI/180}function l(e){return!isNaN(e)&&e!==null&&!Array.isArray(e)}export{w as a,d as b,c,b as d,h as f,g as l,u as p,m as r};
